import logging
from datetime import datetime, timedelta, timezone
from typing import TYPE_CHECKING
from uuid import UUID

import jwt
from fastapi import HTTPException

from . import api
from .api.api_key import get_key
from .api.api_key.schema import ApiKeyRead
from .api.tree.schema import TreeRead
from .db import get_session
from .env import Environment, env

if TYPE_CHECKING:
    from .api.user.schema import UserRead

logger = logging.getLogger(__name__)
logger.setLevel(logging.ERROR)


"""
Token 
    audience                payload (plus kid, exp)
    gateway->earth          tree_uuid, tree_id
    client->gateway         tree_uuid, tree_id
    client->earth           user_uuid
"""


async def new_gateway2earth(
    *, tree: TreeRead, api_key: ApiKeyRead, validity: timedelta = env.GATEWAY_EARTH_VALIDITY
) -> str:
    payload = {
        "exp": datetime.now(timezone.utc) + validity,
        "aud": "gateway->earth",
        "tree_uuid": str(tree.uuid),
        "tree_id": tree.tree_id,
    }
    return jwt.encode(payload, str(api_key.key), headers={"kid": str(api_key.uuid)}, algorithm="HS256")


async def new_client2gateway(*, tree: TreeRead, validity: timedelta = env.CLIENT_GATEWAY_VALIDITY) -> str:
    payload = {
        "exp": datetime.now(timezone.utc) + validity,
        "aud": "client->gateway",
        "tree_uuid": str(tree.uuid),
        "tree_id": tree.tree_id,
    }
    return jwt.encode(payload, key=tree.tree_key, headers={"kid": str(tree.kid)}, algorithm="HS256")


async def new_client2earth(
    *, user_uuid: UUID, api_key: ApiKeyRead, validity: timedelta = env.CLIENT_EARTH_VALIDITY
) -> str:
    payload = {
        "exp": datetime.now(timezone.utc) + validity,
        "aud": "client->earth",
        "user_uuid": str(user_uuid),
    }
    return jwt.encode(payload, str(api_key.key), headers={"kid": str(api_key.uuid)}, algorithm="HS256")


async def verify_gateway2earth(token: str) -> TreeRead:
    """
    Verify the authenticity and validity of a gateway token.

    Args:
        token: The token to be verified.

    Returns:
        The tree associated with the token.

    Raises:
        HTTPException: If the token is invalid, expired, or the associated tree is not found or disabled.
    """
    # during development, we don't verify the token to accept tokens generated by the production server
    # in any case, we return the tree
    verify = env.ENVIRONMENT != Environment.development

    try:
        header = jwt.get_unverified_header(token)
    except jwt.DecodeError as e:
        raise HTTPException(status_code=401, detail=f"Corrupt token: {e}")

    async for session in get_session():
        if verify:
            api_key = await get_key(db_session=session, kid=header.get("kid", "no kid"))
            key = api_key.key
        else:
            key = ""
        try:
            payload = jwt.decode(
                token,
                key=key,
                audience="gateway->earth",
                algorithms=["HS256"],
                options={"verify_signature": verify},
            )
            # check that the tree exists and is not disabled
            if verify:
                tree = await api.tree.crud.get_by_uuid(uuid=payload.get("tree_uuid"), db_session=session)
            else:
                # use tree_id to allow configurations generated on production server be used in development
                tree = await api.tree.crud.get_by_tree_id(tree_id=payload.get("tree_id"), db_session=session)
            if tree.disabled:
                logger.info(f"tree disabled {tree.tree_id}")
                raise HTTPException(status_code=403, detail="Tree disabled")
            return tree
        except jwt.DecodeError as e:
            logger.error(f"invalid token: {token}")
            logger.error(f"key: {key}")
            raise HTTPException(status_code=401, detail=f"Invalid token: {e}")
    else:
        raise HTTPException(status_code=500, detail="no db session")


async def verify_client2earth(token: str) -> "UserRead":
    """Verifies the client token checking its validity and expiration.

    Args:
        token: The client token to be verified.

    Returns:
        The user associated with the token.

    Raises:
        HTTPException: If the token is invalid, expired, or the user is not known or suspended.
    """

    if token is None:
        logger.error("no token provided")
        raise HTTPException(status_code=401, detail="No token provided")

    try:
        header = jwt.get_unverified_header(token)
    except jwt.DecodeError as e:
        raise HTTPException(status_code=401, detail=f"Corrupt token: {e}")

    async for session in get_session():
        key = await api.api_key.get_key(db_session=session, kid=header.get("kid", "no kid"))
        try:
            payload = jwt.decode(token, key=str(key.key), audience="client->earth", algorithms=["HS256"])
            user = await api.user.crud.get_by_uuid(db_session=session, uuid=payload.get("user_uuid"))
            if user.disabled:
                raise HTTPException(status_code=403, detail="User suspended")

            return user

        except jwt.DecodeError as e:
            logger.error(f"invalid token: {token}")
            logger.error(f"key: {key.key}")
            raise HTTPException(status_code=401, detail=f"Invalid token: {e}")
    else:
        raise HTTPException(status_code=500, detail="no db session")
